From 68a831a3ee9fc9798936b2110193da54d872fea1 Mon Sep 17 00:00:00 2001
From: "F. Moukayed" <7354509+fmqa@users.noreply.github.com>
Date: Sat, 29 May 2021 12:52:03 +0000
Subject: [PATCH] Add support for server-generated waveform data through a
 custom EXT-X-PEAKDATA extension

---
 libavformat/dashenc.c     |   2 +-
 libavformat/hlsenc.c      | 261 +++++++++++++++++++++++++++++++++++++-
 libavformat/hlsplaylist.c |  48 ++++++-
 3 files changed, 307 insertions(+), 4 deletions(-)

diff --git a/libavformat/dashenc.c b/libavformat/dashenc.c
index 81a5c2b452..b2c8985140 100644
--- a/libavformat/dashenc.c
+++ b/libavformat/dashenc.c
@@ -575,7 +575,7 @@ static void write_hls_media_playlist(OutputStream *os, AVFormatContext *s,
                                 (double) seg->duration / timescale, 0,
                                 seg->range_length, seg->start_pos, NULL,
                                 c->single_file ? os->initfile : seg->file,
-                                &prog_date_time, 0, 0, 0);
+                                &prog_date_time, 0, 0, 0, NULL, NULL);
         if (ret < 0) {
             av_log(os->ctx, AV_LOG_WARNING, "ff_hls_write_file_entry get error\n");
         }
diff --git a/libavformat/hlsenc.c b/libavformat/hlsenc.c
index 7d97ce1789..0fa325b3cc 100644
--- a/libavformat/hlsenc.c
+++ b/libavformat/hlsenc.c
@@ -44,6 +44,8 @@
 #include "libavutil/time.h"
 #include "libavutil/time_internal.h"
 
+#include "libswresample/swresample.h"
+
 #include "avformat.h"
 #include "avio_internal.h"
 #include "avc.h"
@@ -73,6 +75,17 @@ typedef enum {
 #define BUFSIZE (16 * 1024)
 #define POSTFIX_PATTERN "_%d"
 
+typedef struct HLSAudioPeakIO {
+    AVStream *st;
+    AVCodecContext *ctx;
+    AVCodec *ac;
+    AVFrame *frame;
+    SwrContext *swr;
+    char *filename;
+    int fd;
+    int16_t *window;
+} HLSAudioPeakIO;
+
 typedef struct HLSSegment {
     char filename[MAX_URL_SIZE];
     char sub_filename[MAX_URL_SIZE];
@@ -89,6 +102,9 @@ typedef struct HLSSegment {
 
     struct HLSSegment *next;
     double discont_program_date_time;
+
+    char *peakfilename;
+    int peakfd;
 } HLSSegment;
 
 typedef enum HLSFlags {
@@ -258,6 +274,12 @@ typedef struct HLSContext {
     char *headers;
     int has_default_key; /* has DEFAULT field of var_stream_map */
     int has_video_m3u8; /* has video stream m3u8 list */
+
+    int audio_peaks;
+
+    HLSAudioPeakIO *apio;
+    int apio_winsize;
+    int apio_sr;
 } HLSContext;
 
 static int strftime_expand(const char *fmt, char **dest)
@@ -683,6 +705,22 @@ static int hls_delete_old_segments(AVFormatContext *s, HLSContext *hls,
             if (ret = hls_delete_file(hls, vs->vtt_avf, path.str, proto))
                 goto fail;
         }
+
+        if (segment->peakfd >= 0) {
+            if (close(segment->peakfd) == 0) {
+                segment->peakfd = -1;
+            } else {
+                av_log(hls, AV_LOG_DEBUG, "error closing segment peak buffer fd: %d\n", segment->peakfd);
+            }
+        }
+        if (segment->peakfilename) {
+            if (unlink(segment->peakfilename) == 0) {
+                segment->peakfilename = NULL;
+            } else {
+                av_log(hls, AV_LOG_DEBUG, "error closing segment peak file: %s\n", segment->peakfilename);
+            }
+        }
+
         av_bprint_clear(&path);
         previous_segment = segment;
         segment = previous_segment->next;
@@ -1105,11 +1143,24 @@ static int sls_flag_use_localtime_filename(AVFormatContext *oc, HLSContext *c, V
     return 0;
 }
 
+static HLSAudioPeakIO *find_apio(int n, HLSAudioPeakIO *apio, VariantStream *vs)
+{
+    for (int i = 0; i < n; ++i) {
+        for (int j = 0; j < vs->nb_streams; ++j) {
+            if (apio[i].st == vs->streams[j]) {
+                return &apio[i];
+            }
+        }
+    }
+    return NULL;
+}
+
 /* Create a new segment and append it to the segment list */
 static int hls_append_segment(struct AVFormatContext *s, HLSContext *hls,
                               VariantStream *vs, double duration, int64_t pos,
                               int64_t size)
 {
+    HLSAudioPeakIO *apio = hls->apio ? find_apio(s->nb_streams, hls->apio, vs) : NULL;
     HLSSegment *en = av_malloc(sizeof(*en));
     const char  *filename;
     int byterange_mode = (hls->flags & HLS_SINGLE_FILE) || (hls->max_seg_size > 0);
@@ -1149,6 +1200,66 @@ static int hls_append_segment(struct AVFormatContext *s, HLSContext *hls,
     en->next     = NULL;
     en->discont  = 0;
     en->discont_program_date_time = 0;
+    en->peakfilename = NULL;
+    en->peakfd = -1;
+
+    if (apio) {
+        double rmsbuf[BUFSIZ];
+        int rmsidx = 0;
+        en->peakfd = avpriv_tempfile("ffhlspeak-seg-", &en->peakfilename, 0, s);
+        if (en->peakfd < 0) {
+            av_log(hls, AV_LOG_WARNING, "Could not open segment peak file: %s\n", en->peakfilename ? en->peakfilename : "(unnamed)");
+            goto apioend;
+        }
+        ret = lseek(apio->fd, 0, SEEK_SET);
+        if (ret < 0) {
+            av_log(hls, AV_LOG_WARNING, "Could not rewind peak buffer file: %s\n", apio->filename ? apio->filename : "(unnamed)");
+            close(en->peakfd);
+            en->peakfd = -1;
+            en->peakfilename = NULL;
+            goto apioend;
+        }
+        while ((ret = read(apio->fd, apio->window, sizeof(int16_t) * hls->apio_winsize)) > 0) {
+            size_t n = ret / sizeof(int16_t);
+            rmsbuf[rmsidx] = 0.0;
+            for (int i = 0; i < n; ++i) {
+                rmsbuf[rmsidx] += apio->window[i] * apio->window[i];
+            }
+            rmsbuf[rmsidx] = sqrt(rmsbuf[rmsidx] / n);
+            ++rmsidx;
+            if (rmsidx >= BUFSIZ) {
+                ret = write(en->peakfd, rmsbuf, rmsidx * sizeof(double));
+                if (ret != rmsidx * sizeof(double)) {
+                    av_log(hls, AV_LOG_WARNING, "Could not write %d RMS peaks to file: %s", rmsidx, en->peakfilename ? en->peakfilename : "(unnamed)");
+                }
+                rmsidx = 0;
+            }
+        }
+        if (rmsidx > 0) {
+            ret = write(en->peakfd, rmsbuf, rmsidx * sizeof(double));
+            if (ret != rmsidx * sizeof(double)) {
+                av_log(hls, AV_LOG_WARNING, "Could not write %d RMS peaks to file: %s", rmsidx, en->peakfilename ? en->peakfilename : "(unnamed)");
+            }
+        }
+        if (ret < 0) {
+            av_log(hls, AV_LOG_WARNING, "Could not read peak buffer file: %s\n", apio->filename ? apio->filename : "(unnamed)");
+        }
+        ret = lseek(apio->fd, 0, SEEK_SET);
+        if (ret < 0) {
+            av_log(hls, AV_LOG_WARNING, "Could not rewind peak buffer file: %s\n", apio->filename ? apio->filename : "(unnamed)");
+        }
+        ret = truncate(apio->filename, 0);
+        if (ret < 0) {
+            av_log(hls, AV_LOG_WARNING, "Could not truncate peak buffer file: %s\n", apio->filename ? apio->filename : "(unnamed)");
+        }
+        ret = close(en->peakfd);
+        if (ret == 0) {
+            en->peakfd = -1;
+        } else {
+            av_log(hls, AV_LOG_WARNING, "Could not close segment peak file: %s\n", en->peakfilename ? en->peakfilename : "(unnamed)");
+        }
+    }
+apioend:
 
     if (vs->discontinuity) {
         en->discont = 1;
@@ -1316,6 +1427,20 @@ static void hls_free_segments(HLSSegment *p)
 
     while (p) {
         en = p;
+        if (en->peakfd >= 0) {
+            if (close(en->peakfd) == 0) {
+                en->peakfd = -1;
+            } else {
+                av_log(NULL, AV_LOG_DEBUG, "error closing segment peak buffer fd: %d\n", en->peakfd);
+            }
+        }
+        if (en->peakfilename) {
+            if (unlink(en->peakfilename) == 0) {
+                en->peakfilename = NULL;
+            } else {
+                av_log(NULL, AV_LOG_DEBUG, "error closing segment peak filename: %s\n", en->peakfilename);
+            }
+        }
         p = p->next;
         av_freep(&en);
     }
@@ -1624,7 +1749,7 @@ static int hls_window(AVFormatContext *s, int last, VariantStream *vs)
                                       en->size, en->pos, hls->baseurl,
                                       en->filename,
                                       en->discont_program_date_time ? &en->discont_program_date_time : prog_date_time_p,
-                                      en->keyframe_size, en->keyframe_pos, hls->flags & HLS_I_FRAMES_ONLY);
+                                      en->keyframe_size, en->keyframe_pos, hls->flags & HLS_I_FRAMES_ONLY, &en->peakfd, &en->peakfilename);
         if (en->discont_program_date_time)
             en->discont_program_date_time -= en->duration;
         if (ret < 0) {
@@ -1647,7 +1772,7 @@ static int hls_window(AVFormatContext *s, int last, VariantStream *vs)
         for (en = vs->segments; en; en = en->next) {
             ret = ff_hls_write_file_entry(hls->sub_m3u8_out, 0, byterange_mode,
                                           en->duration, 0, en->size, en->pos,
-                                          hls->baseurl, en->sub_filename, NULL, 0, 0, 0);
+                                          hls->baseurl, en->sub_filename, NULL, 0, 0, 0, &en->peakfd, &en->peakfilename);
             if (ret < 0) {
                 av_log(s, AV_LOG_WARNING, "ff_hls_write_file_entry get error\n");
             }
@@ -2673,6 +2798,47 @@ static int hls_write_packet(AVFormatContext *s, AVPacket *pkt)
     vs->packets_written++;
     if (oc->pb) {
         int64_t keyframe_pre_pos = avio_tell(oc->pb);
+        if (st->codecpar->codec_type == AVMEDIA_TYPE_AUDIO && hls->apio && hls->apio[pkt->stream_index].st == st) {
+            int frames;
+            int16_t *buffer = NULL;
+            if (!hls->apio[pkt->stream_index].frame) {
+                hls->apio[pkt->stream_index].frame = av_frame_alloc();
+                if (!hls->apio[pkt->stream_index].frame) {
+                    return AVERROR(ENOMEM);
+                }
+            }
+            ret = avcodec_send_packet(hls->apio[pkt->stream_index].ctx, pkt);
+            if (ret < 0) {
+                return ret;
+            }
+            ret = avcodec_receive_frame(hls->apio[pkt->stream_index].ctx, hls->apio[pkt->stream_index].frame);
+            if (ret == AVERROR(EAGAIN) || ret == AVERROR_EOF) {
+                goto chain;
+            } else if (ret < 0) {
+                return ret;
+            }
+            ret = av_samples_alloc((uint8_t**)&buffer, NULL, 1, hls->apio[pkt->stream_index].frame->nb_samples, AV_SAMPLE_FMT_S16P, 0);
+            if (ret < 0) {
+                return ret;
+            }
+            frames = swr_convert(
+                hls->apio[pkt->stream_index].swr,
+                (uint8_t**)&buffer,
+                hls->apio[pkt->stream_index].frame->nb_samples,
+                (const uint8_t**)hls->apio[pkt->stream_index].frame->data,
+                hls->apio[pkt->stream_index].frame->nb_samples);
+            if (frames < 0) {
+                av_freep(&buffer);
+                return frames;
+            }
+            ret = write(hls->apio[pkt->stream_index].fd, buffer, sizeof(*buffer) * frames);
+            if (ret < 0) {
+                av_freep(&buffer);
+                return AVERROR(errno);
+            }
+            av_freep(&buffer);
+        }
+chain:
         ret = ff_write_chained(oc, stream_index, pkt, s, 0);
         if ((st->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) &&
             (pkt->flags & AV_PKT_FLAG_KEY) && !keyframe_pre_pos) {
@@ -2712,6 +2878,37 @@ static void hls_deinit(AVFormatContext *s)
         av_freep(&vs->streams);
     }
 
+    if (hls->apio) {
+        for (int i = 0; i < s->nb_streams; ++i) {
+            if (hls->apio[i].frame) {
+                av_frame_free(&hls->apio[i].frame);
+                hls->apio[i].frame = NULL;
+            }
+            if (hls->apio[i].ctx) {
+                avcodec_close(hls->apio[i].ctx);
+                hls->apio[i].ctx = NULL;
+            }
+            if (hls->apio[i].swr) {
+                swr_free(&hls->apio[i].swr);
+                hls->apio[i].swr = NULL;
+            }
+            if (hls->apio[i].window) {
+                av_free(hls->apio[i].window);
+                hls->apio[i].window = NULL;
+            }
+            if (hls->apio[i].fd >= 0) {
+                close(hls->apio[i].fd);
+                hls->apio[i].fd = -1;
+            }
+            if (hls->apio[i].filename) {
+                unlink(hls->apio[i].filename);
+                hls->apio[i].filename = NULL;
+            }
+        }
+        av_free(hls->apio);
+        hls->apio = NULL;
+    }
+
     ff_format_io_close(s, &hls->m3u8_out);
     ff_format_io_close(s, &hls->sub_m3u8_out);
     av_freep(&hls->key_basename);
@@ -2925,6 +3122,63 @@ static int hls_init(AVFormatContext *s)
         }
     }
 
+    if (hls->audio_peaks) {
+        hls->apio = av_mallocz(sizeof(*hls->apio) * s->nb_streams);
+        if (!hls->apio) {
+            return AVERROR(ENOMEM);
+        }
+        for (int i = 0; i < s->nb_streams; ++i) {
+            if (s->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_AUDIO) {
+                hls->apio[i].st = s->streams[i];
+                hls->apio[i].ctx = avcodec_alloc_context3(NULL);
+                if (!hls->apio[i].ctx) {
+                    return AVERROR(ENOMEM);
+                }
+                ret = avcodec_parameters_to_context(hls->apio[i].ctx, s->streams[i]->codecpar);
+                if (ret < 0) {
+                    return ret;
+                }
+                hls->apio[i].ac = avcodec_find_decoder(hls->apio[i].ctx->codec_id);
+                if (!hls->apio[i].ac) {
+                    av_log(s, AV_LOG_ERROR, "Could not find input codec\n");
+                    return -1;
+                }
+                hls->apio[i].swr = swr_alloc();
+                if (!hls->apio[i].swr) {
+                    return AVERROR(ENOMEM);
+                }
+                av_opt_set_int(hls->apio[i].swr, "in_channel_count", s->streams[i]->codecpar->channels, 0);
+                av_opt_set_int(hls->apio[i].swr, "out_channel_count", 1, 0);
+                av_opt_set_int(hls->apio[i].swr, "in_channel_layout", s->streams[i]->codecpar->channel_layout, 0);
+                av_opt_set_int(hls->apio[i].swr, "out_channel_layout", AV_CH_LAYOUT_MONO, 0);
+                av_opt_set_int(hls->apio[i].swr, "in_sample_rate", s->streams[i]->codecpar->sample_rate, 0);
+                av_opt_set_int(hls->apio[i].swr, "out_sample_rate", hls->apio_sr, 0);
+                av_opt_set_sample_fmt(hls->apio[i].swr, "in_sample_fmt", s->streams[i]->codecpar->format, 0);
+                av_opt_set_sample_fmt(hls->apio[i].swr, "out_sample_fmt", AV_SAMPLE_FMT_S16P, 0);
+                ret = swr_init(hls->apio[i].swr);
+                if (ret < 0) {
+                    return ret;
+                }
+                ret = avcodec_open2(hls->apio[i].ctx, hls->apio[i].ac, NULL);
+                if (ret < 0) {
+                    return ret;
+                }
+                hls->apio[i].fd = avpriv_tempfile("ffhlspeak-", &hls->apio[i].filename, 0, s);
+                if (hls->apio[i].fd < 0) {
+                    ret = errno;
+                    av_log(s, AV_LOG_ERROR, "Could not create temporary file for peaks: %s\n", strerror(ret));
+                    return AVERROR(ret);
+                }
+                hls->apio[i].window = av_malloc(hls->apio_winsize * sizeof(int16_t));
+                if (!hls->apio[i].window) {
+                    return AVERROR(ENOMEM);
+                }
+            }
+        }
+    } else {
+        hls->apio = NULL;
+    }
+
     if ((hls->start_sequence_source_type == HLS_START_SEQUENCE_AS_SECONDS_SINCE_EPOCH) ||
         (hls->start_sequence_source_type == HLS_START_SEQUENCE_AS_MICROSECONDS_SINCE_EPOCH) ||
         (hls->start_sequence_source_type == HLS_START_SEQUENCE_AS_FORMATTED_DATETIME)) {
@@ -3180,6 +3434,9 @@ static const AVOption options[] = {
     {"timeout", "set timeout for socket I/O operations", OFFSET(timeout), AV_OPT_TYPE_DURATION, { .i64 = -1 }, -1, INT_MAX, .flags = E },
     {"ignore_io_errors", "Ignore IO errors for stable long-duration runs with network output", OFFSET(ignore_io_errors), AV_OPT_TYPE_BOOL, { .i64 = 0 }, 0, 1, E },
     {"headers", "set custom HTTP headers, can override built in default headers", OFFSET(headers), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, E },
+    {"hls_audio_peaks", "Add per-segment EXT-X-PEAKDATA time series data to playlist", OFFSET(audio_peaks), AV_OPT_TYPE_BOOL, {.i64 = 0 }, 0, 1, E },
+    {"hls_audio_peaks_window", "EXT-X-PEAKDATA window size",  OFFSET(apio_winsize),    AV_OPT_TYPE_INT,    {.i64 = 1000},               1,       INT_MAX,   E},
+    {"hls_audio_peaks_rate", "Sampling rate for waveform calculation",  OFFSET(apio_sr),    AV_OPT_TYPE_INT,    {.i64 = 8000},               1,       INT_MAX,   E},
     { NULL },
 };
 
diff --git a/libavformat/hlsplaylist.c b/libavformat/hlsplaylist.c
index 0e1dcc087f..3601891361 100644
--- a/libavformat/hlsplaylist.c
+++ b/libavformat/hlsplaylist.c
@@ -28,6 +28,17 @@
 #include "avformat.h"
 #include "hlsplaylist.h"
 
+#include <fcntl.h>
+#if HAVE_IO_H
+#include <io.h>
+#endif
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <sys/stat.h>
+#include <stdlib.h>
+#include "os_support.h"
+
 void ff_hls_write_playlist_version(AVIOContext *out, int version)
 {
     if (!out)
@@ -136,7 +147,7 @@ int ff_hls_write_file_entry(AVIOContext *out, int insert_discont,
                             const char *baseurl /* Ignored if NULL */,
                             const char *filename, double *prog_date_time,
                             int64_t video_keyframe_size, int64_t video_keyframe_pos,
-                            int iframe_mode)
+                            int iframe_mode, int *peakfd, char **peakfilename)
 {
     if (!out || !filename)
         return AVERROR(EINVAL);
@@ -179,6 +190,41 @@ int ff_hls_write_file_entry(AVIOContext *out, int insert_discont,
         avio_printf(out, "#EXT-X-PROGRAM-DATE-TIME:%s.%03d%s\n", buf0, milli, buf1);
         *prog_date_time += duration;
     }
+
+    if (peakfilename && *peakfilename && peakfd) {
+        int ret;
+        double buffer[BUFSIZ];
+        int header = 0;
+
+        if (*peakfd < 0) {
+            *peakfd = avpriv_open(*peakfilename, O_RDONLY);
+            if (*peakfd < 0) {
+                av_log(NULL, AV_LOG_WARNING, "open() error in ff_hls_write_file_entry\n");
+                goto post_apio;
+            }
+        }
+
+        while ((ret = read(*peakfd, buffer, sizeof(buffer))) > 0) {
+            if (!header) {
+                avio_printf(out, "#EXT-X-PEAKDATA:");
+                header = 1;
+            }
+            for (int i = 0, n = ret / sizeof(double); i < n; ++i) {
+                avio_printf(out, "%.1lf%c", buffer[i], i + 1 < n ? ',' : '\n');
+            }
+        }
+
+        if (close(*peakfd) == 0) {
+            *peakfd = -1;
+        } else {
+            av_log(NULL, AV_LOG_WARNING, "close error in ff_hls_write_file_entry\n");
+        }
+
+        if (ret < 0) {
+            av_log(NULL, AV_LOG_WARNING, "read error in ff_hls_write_file_entry\n");
+        }
+    }
+post_apio:
     if (baseurl)
         avio_printf(out, "%s", baseurl);
     avio_printf(out, "%s\n", filename);
-- 
2.25.1

